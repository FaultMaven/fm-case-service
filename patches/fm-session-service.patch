From 684289f51f0a94810a05a5f10ac3f366ede4940c Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Mon, 15 Dec 2025 03:03:23 +0000
Subject: [PATCH] docs: Implement automated documentation workflow

Add comprehensive automated documentation system following fm-case-service gold standard:

1. Created .github/workflows/generate-docs.yml:
   - Triggers on push to main/develop with path filters
   - workflow_dispatch for manual triggering
   - Generates OpenAPI spec from session_service.main:app (JSON + YAML)
   - Validates documentation completeness (min 100 char descriptions, response codes)
   - Creates PR for auto-generated docs using peter-evans/create-pull-request@v5
   - Uploads OpenAPI spec as build artifact

2. Created scripts/generate_readme.py:
   - Reads docs/api/openapi.json
   - Generates comprehensive README with endpoint table
   - Includes response codes section
   - Adds documentation statistics and timestamp
   - Tailored for fm-session-service (Redis storage, session management)

3. Enhanced docstrings for 7 endpoints in sessions.py:
   - get_session_cases: Retrieve cases from fm-case-service
   - get_session_stats: Session statistics and metrics
   - add_session_message: Append messages to conversation
   - get_session_messages: Retrieve message history with pagination
   - search_sessions: Search/filter sessions by status and query
   - archive_session: Archive session preserving data
   - restore_session: Restore archived session to active

Each docstring includes:
- Workflow explanation (step-by-step process)
- Request/response examples with JSON
- Use cases and behavior notes
- Storage markers (Redis operations)
- Authorization requirements (X-User-ID header)
- Rate limit info
- Comprehensive responses dict (200/401/403/404/500)

All endpoints now meet validation requirements:
- Min 100 character descriptions
- Success response codes (200/201/204)
- Error response codes (401/403/404/500)
---
 .github/workflows/generate-docs.yml        | 214 ++++++++++
 scripts/generate_readme.py                 | 433 +++++++++++++++++++++
 src/session_service/api/routes/sessions.py | 393 ++++++++++++++++++-
 3 files changed, 1032 insertions(+), 8 deletions(-)
 create mode 100644 .github/workflows/generate-docs.yml
 create mode 100644 scripts/generate_readme.py

diff --git a/.github/workflows/generate-docs.yml b/.github/workflows/generate-docs.yml
new file mode 100644
index 0000000..cd908cc
--- /dev/null
+++ b/.github/workflows/generate-docs.yml
@@ -0,0 +1,214 @@
+name: Generate Documentation
+
+on:
+  push:
+    branches: [main, develop]
+    paths:
+      - 'src/**/api/**'              # API routes
+      - 'src/**/models/**'           # Pydantic models
+      - 'src/**/main.py'             # App entry point
+      - 'scripts/generate_readme.py' # README generator
+      - 'pyproject.toml'             # Version changes
+  pull_request:
+    branches: [main]
+    paths:
+      - 'src/**/api/**'
+      - 'src/**/models/**'
+      - 'src/**/main.py'
+      - 'scripts/generate_readme.py'
+      - 'pyproject.toml'
+  workflow_dispatch:  # Allow manual trigger for initial setup or debugging
+
+jobs:
+  generate-docs:
+    runs-on: ubuntu-latest
+
+    steps:
+      - name: Checkout code
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0  # Full history for better git operations
+
+      - name: Set up Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.13'
+          cache: 'pip'
+
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install -e .
+          pip install pyyaml
+
+      - name: Generate OpenAPI Specification
+        run: |
+          python -c "
+          from session_service.main import app
+          import json
+          import yaml
+          import os
+
+          # Generate OpenAPI spec
+          spec = app.openapi()
+
+          # Create docs directory
+          os.makedirs('docs/api', exist_ok=True)
+
+          # Write JSON spec
+          with open('docs/api/openapi.json', 'w') as f:
+              json.dump(spec, f, indent=2)
+
+          # Write YAML spec
+          with open('docs/api/openapi.yaml', 'w') as f:
+              yaml.dump(spec, f, default_flow_style=False, sort_keys=False)
+
+          print('âœ… OpenAPI specification generated')
+          print(f'  - docs/api/openapi.json ({os.path.getsize(\"docs/api/openapi.json\")} bytes)')
+          print(f'  - docs/api/openapi.yaml ({os.path.getsize(\"docs/api/openapi.yaml\")} bytes)')
+          "
+
+      - name: Validate Documentation Completeness
+        run: |
+          python -c "
+          from session_service.main import app
+          import sys
+
+          spec = app.openapi()
+          incomplete = []
+          warnings = []
+          endpoints_checked = 0
+
+          # Required response codes that should be documented
+          REQUIRED_SUCCESS_CODES = {'200', '201', '204'}
+          REQUIRED_ERROR_CODES = {'400', '401', '404', '422', '500'}
+
+          # Minimum description length for comprehensive docs (chars)
+          MIN_DESCRIPTION_LENGTH = 100
+
+          # Check all endpoints for required documentation
+          for path, methods in spec.get('paths', {}).items():
+              for method, details in methods.items():
+                  if method.lower() in ['get', 'post', 'put', 'delete', 'patch']:
+                      endpoints_checked += 1
+                      endpoint_id = f'{method.upper()} {path}'
+
+                      # Check for summary
+                      summary = details.get('summary', '').strip()
+                      if not summary:
+                          incomplete.append(f'{endpoint_id} - missing summary')
+
+                      # Check for description
+                      description = details.get('description', '').strip()
+                      if not description:
+                          incomplete.append(f'{endpoint_id} - missing description')
+                      elif len(description) < MIN_DESCRIPTION_LENGTH:
+                          incomplete.append(f'{endpoint_id} - description too short ({len(description)} chars, min {MIN_DESCRIPTION_LENGTH})')
+
+                      # Check for responses dict
+                      responses = details.get('responses', {})
+                      if not responses:
+                          incomplete.append(f'{endpoint_id} - missing responses')
+                      else:
+                          response_codes = set(responses.keys())
+
+                          # Check for at least one success code
+                          if not response_codes.intersection(REQUIRED_SUCCESS_CODES):
+                              incomplete.append(f'{endpoint_id} - missing success response (200/201/204)')
+
+                          # Check for 401 (auth required for most endpoints)
+                          if '401' not in response_codes and '/health' not in path:
+                              warnings.append(f'{endpoint_id} - missing 401 response')
+
+                          # Check for 500 (internal error)
+                          if '500' not in response_codes and '/health' not in path:
+                              warnings.append(f'{endpoint_id} - missing 500 response')
+
+          print(f'ðŸ“Š Documentation Validation Report')
+          print(f'  Total endpoints checked: {endpoints_checked}')
+          print()
+
+          if warnings:
+              print(f'âš ï¸  Warnings: {len(warnings)}')
+              for item in warnings:
+                  print(f'    - {item}')
+              print()
+
+          if incomplete:
+              print(f'âŒ Incomplete documentation: {len(incomplete)} issue(s)')
+              print()
+              print('Errors (must fix):')
+              for item in incomplete:
+                  print(f'  - {item}')
+              print()
+              print('Documentation requirements:')
+              print('  - summary: One-line description (required)')
+              print('  - description: Comprehensive docs with examples, workflow, auth info (min 100 chars)')
+              print('  - responses: Dict with success (200/201/204) and error codes (400/401/404/500)')
+              sys.exit(1)
+          else:
+              print(f'âœ… All {endpoints_checked} endpoints fully documented')
+              if warnings:
+                  print(f'   (with {len(warnings)} non-blocking warnings)')
+          "
+
+      - name: Generate README
+        run: |
+          python scripts/generate_readme.py
+          echo "âœ… README.md generated"
+
+      - name: Check for documentation changes
+        id: check_changes
+        run: |
+          git add docs/api/*.json docs/api/*.yaml README.md
+          if git diff --staged --quiet; then
+            echo "has_changes=false" >> $GITHUB_OUTPUT
+            echo "ðŸ“ No documentation changes detected"
+          else
+            echo "has_changes=true" >> $GITHUB_OUTPUT
+            echo "ðŸ“ Documentation changes detected"
+            git diff --staged --stat
+          fi
+
+      - name: Create Pull Request for documentation updates
+        if: |
+          github.event_name == 'push' &&
+          github.ref == 'refs/heads/main' &&
+          steps.check_changes.outputs.has_changes == 'true'
+        uses: peter-evans/create-pull-request@v5
+        with:
+          token: ${{ secrets.GITHUB_TOKEN }}
+          commit-message: "docs: Auto-generate API documentation"
+          branch: docs/auto-update-${{ github.run_id }}
+          delete-branch: true
+          title: "docs: Auto-update API documentation"
+          body: |
+            ## ðŸ¤– Auto-generated Documentation Update
+
+            This PR was automatically created by the documentation workflow.
+
+            ### Changes
+            - Updated OpenAPI specification (JSON + YAML)
+            - Regenerated README.md from code
+
+            ### Trigger
+            - **Commit:** ${{ github.sha }}
+            - **Message:** ${{ github.event.head_commit.message }}
+            - **Author:** ${{ github.event.head_commit.author.name }}
+
+            ### Validation
+            âœ… All endpoints have required documentation (summary, description, responses)
+
+            ---
+            *This PR can be auto-merged if documentation looks correct.*
+          labels: |
+            documentation
+            automated
+          reviewers: ${{ github.actor }}
+
+      - name: Upload OpenAPI spec as artifact
+        uses: actions/upload-artifact@v3
+        with:
+          name: openapi-spec
+          path: docs/api/
+          retention-days: 30
diff --git a/scripts/generate_readme.py b/scripts/generate_readme.py
new file mode 100644
index 0000000..bfb9015
--- /dev/null
+++ b/scripts/generate_readme.py
@@ -0,0 +1,433 @@
+#!/usr/bin/env python3
+"""Auto-generate README.md from OpenAPI specification.
+
+This script reads the OpenAPI spec generated from FastAPI and creates
+a comprehensive README with endpoint documentation, examples, and statistics.
+"""
+
+import json
+from pathlib import Path
+from datetime import datetime
+from typing import Dict, List, Set, Any
+
+
+def load_openapi_spec() -> Dict[str, Any]:
+    """Load OpenAPI spec from docs/api/openapi.json"""
+    spec_path = Path(__file__).parent.parent / "docs" / "api" / "openapi.json"
+
+    if not spec_path.exists():
+        raise FileNotFoundError(
+            f"OpenAPI spec not found at {spec_path}. "
+            "Run the app to generate it first."
+        )
+
+    with open(spec_path, 'r') as f:
+        return json.load(f)
+
+
+def generate_endpoint_table(spec: Dict[str, Any]) -> str:
+    """Generate markdown table of endpoints"""
+    endpoints = []
+
+    for path, methods in spec.get('paths', {}).items():
+        for method, details in methods.items():
+            if method.lower() in ['get', 'post', 'put', 'delete', 'patch']:
+                # Extract summary or use path as fallback
+                summary = details.get('summary', path)
+
+                endpoints.append({
+                    'method': method.upper(),
+                    'path': path,
+                    'summary': summary
+                })
+
+    # Sort endpoints: health first, then by path
+    def sort_key(e):
+        if e['path'] == '/health':
+            return (0, '')
+        return (1, e['path'])
+
+    endpoints.sort(key=sort_key)
+
+    # Build markdown table
+    table = "| Method | Endpoint | Description |\n"
+    table += "|--------|----------|-------------|\n"
+
+    for endpoint in endpoints:
+        table += f"| {endpoint['method']} | `{endpoint['path']}` | {endpoint['summary']} |\n"
+
+    return table
+
+
+def extract_response_codes(spec: Dict[str, Any]) -> Dict[str, Set[str]]:
+    """Extract unique response codes and their descriptions across all endpoints"""
+    response_info = {}
+
+    for path, methods in spec.get('paths', {}).items():
+        for method, details in methods.items():
+            if method.lower() in ['get', 'post', 'put', 'delete', 'patch']:
+                for code, response_details in details.get('responses', {}).items():
+                    desc = response_details.get('description', 'No description')
+                    if code not in response_info:
+                        response_info[code] = set()
+                    response_info[code].add(desc)
+
+    return response_info
+
+
+def generate_response_codes_section(spec: Dict[str, Any]) -> str:
+    """Generate response codes documentation"""
+    response_info = extract_response_codes(spec)
+
+    if not response_info:
+        return ""
+
+    section = "\n## Common Response Codes\n\n"
+
+    # Sort codes numerically
+    for code in sorted(response_info.keys(), key=lambda x: int(x)):
+        descriptions = list(response_info[code])
+        section += f"- **{code}**: {descriptions[0]}\n"
+
+    return section
+
+
+def count_endpoints(spec: Dict[str, Any]) -> int:
+    """Count total number of endpoints"""
+    count = 0
+    for path, methods in spec.get('paths', {}).items():
+        for method in methods.keys():
+            if method.lower() in ['get', 'post', 'put', 'delete', 'patch']:
+                count += 1
+    return count
+
+
+def main():
+    """Generate README.md from OpenAPI specification"""
+    print("ðŸš€ Generating README.md from OpenAPI specification...")
+
+    # Load spec
+    spec = load_openapi_spec()
+
+    # Extract metadata
+    info = spec.get('info', {})
+    title = info.get('title', 'fm-session-service')
+    version = info.get('version', '1.0.0')
+    description = info.get('description', 'Session management microservice')
+
+    # Generate sections
+    endpoint_table = generate_endpoint_table(spec)
+    response_codes = generate_response_codes_section(spec)
+    total_endpoints = count_endpoints(spec)
+    timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
+
+    # Build README content
+    readme_content = f"""# {title}
+
+> **ðŸ¤– This README is auto-generated** from code on every commit.
+> Last updated: **{timestamp}** | Total endpoints: **{total_endpoints}**
+
+[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](LICENSE)
+[![Docker](https://img.shields.io/badge/docker-ready-blue.svg)](https://hub.docker.com/r/faultmaven/fm-session-service)
+[![Auto-Docs](https://img.shields.io/badge/docs-auto--generated-success.svg)](.github/workflows/generate-docs.yml)
+
+## Overview
+
+**{description}** - Part of the FaultMaven troubleshooting platform.
+
+The Session Service manages troubleshooting investigation sessions in FaultMaven. Sessions are interactive workspaces where users conduct troubleshooting investigations, chat with AI assistants, and track their problem-solving workflow.
+
+**Key Features:**
+- **Session Lifecycle**: Create, retrieve, update, and delete troubleshooting sessions
+- **User Isolation**: Each user only sees their own sessions (enforced via X-User-ID header)
+- **Message Management**: Add and retrieve conversation messages within sessions
+- **Session Statistics**: Track message counts, duration, and activity timestamps
+- **Status Tracking**: Monitor session progression (active â†’ in_progress â†’ completed/archived)
+- **Case Integration**: Link sessions to cases in fm-case-service for long-term tracking
+- **Search & Filter**: Find sessions by status, title, or query parameters
+- **Archive/Restore**: Archive inactive sessions and restore them when needed
+- **Redis Storage**: Fast, in-memory session data with optional persistence
+
+## Quick Start
+
+### Using Docker (Recommended)
+
+```bash
+docker run -p 8001:8001 -e REDIS_URL=redis://redis:6379 faultmaven/fm-session-service:latest
+```
+
+The service will be available at `http://localhost:8001`. Requires a Redis instance for session storage.
+
+### Using Docker Compose
+
+See [faultmaven-deploy](https://github.com/FaultMaven/faultmaven-deploy) for complete deployment with all FaultMaven services.
+
+### Development Setup
+
+```bash
+# Clone repository
+git clone https://github.com/FaultMaven/fm-session-service.git
+cd fm-session-service
+
+# Create virtual environment
+python -m venv .venv
+source .venv/bin/activate  # On Windows: .venv\\Scripts\\activate
+
+# Install dependencies
+pip install -e .
+
+# Set up Redis (requires Docker)
+docker run -d -p 6379:6379 redis:7-alpine
+
+# Run service
+uvicorn session_service.main:app --reload --port 8001
+```
+
+The service connects to Redis at `redis://localhost:6379` by default (configurable via REDIS_URL).
+
+## API Endpoints
+
+{endpoint_table}
+
+**OpenAPI Documentation**: See [docs/api/openapi.json](docs/api/openapi.json) or [docs/api/openapi.yaml](docs/api/openapi.yaml) for complete API specification.
+{response_codes}
+
+## Configuration
+
+Configuration via environment variables:
+
+| Variable | Description | Default |
+|----------|-------------|---------|
+| `SERVICE_NAME` | Service identifier | `fm-session-service` |
+| `SERVICE_VERSION` | Service version | `1.0.0` |
+| `ENVIRONMENT` | Deployment environment | `development` |
+| `HOST` | Service host | `0.0.0.0` |
+| `PORT` | Service port | `8001` |
+| `REDIS_URL` | Redis connection string | `redis://localhost:6379` |
+| `DEFAULT_SESSION_TTL` | Session TTL in seconds | `86400` (24 hours) |
+| `CORS_ORIGINS` | Allowed CORS origins (comma-separated) | `*` |
+| `LOG_LEVEL` | Logging level (DEBUG/INFO/WARNING/ERROR) | `INFO` |
+
+Example `.env` file:
+
+```env
+ENVIRONMENT=production
+PORT=8001
+REDIS_URL=redis://redis-cluster:6379/0
+DEFAULT_SESSION_TTL=604800
+LOG_LEVEL=INFO
+CORS_ORIGINS=https://app.faultmaven.com,https://admin.faultmaven.com
+```
+
+## Session Data Model
+
+Example Session Object:
+
+```json
+{{
+    "session_id": "session_abc123def456",
+    "user_id": "user_123",
+    "title": "Investigating database timeout issues",
+    "description": "Production RDS experiencing connection timeouts",
+    "status": "in_progress",
+    "messages": [
+        {{
+            "role": "user",
+            "content": "What's causing the database timeouts?",
+            "timestamp": "2025-11-15T10:30:00Z"
+        }},
+        {{
+            "role": "assistant",
+            "content": "Let me help investigate...",
+            "timestamp": "2025-11-15T10:30:05Z"
+        }}
+    ],
+    "metadata": {{"environment": "production", "component": "database"}},
+    "created_at": "2025-11-15T10:30:00Z",
+    "last_activity_at": "2025-11-15T10:35:00Z"
+}}
+```
+
+### Status Values
+- `active` - Session created, not yet started
+- `in_progress` - Investigation actively underway
+- `completed` - Investigation finished successfully
+- `archived` - Session archived for reference
+- `abandoned` - Session abandoned without completion
+
+### Message Structure
+Messages follow a chat-like format:
+- `role`: Either "user" or "assistant"
+- `content`: The message text
+- `timestamp`: ISO 8601 timestamp
+
+## Authorization
+
+This service uses **trusted header authentication** from the FaultMaven API Gateway:
+
+**Required Headers:**
+
+- `X-User-ID` (required): Identifies the user making the request
+
+**Optional Headers:**
+
+- `X-User-Email`: User's email address
+- `X-User-Roles`: User's roles (comma-separated)
+
+All session operations are scoped to the user specified in `X-User-ID`. Users can only access their own sessions.
+
+**Security Model:**
+
+- âœ… User isolation enforced at storage level (Redis key prefixing)
+- âœ… All endpoints validate X-User-ID header presence
+- âœ… Cross-user access attempts return 404 (not 403) to prevent enumeration
+- âš ï¸ Service trusts headers set by upstream gateway
+
+**Important**: This service should run behind the [fm-api-gateway](https://github.com/FaultMaven/faultmaven) which handles authentication and sets these headers. Never expose this service directly to the internet.
+
+## Architecture
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚  FaultMaven API Gateway â”‚  Handles authentication (Clerk)
+â”‚  (Port 8000)            â”‚  Sets X-User-ID header
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+            â”‚ Trusted headers (X-User-ID)
+            â†“
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚  fm-session-service     â”‚  Trusts gateway headers
+â”‚  (Port 8001)            â”‚  Enforces user isolation
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+            â”‚ Redis commands
+            â†“
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚  Redis                  â”‚  In-memory session storage
+â”‚  (Port 6379)            â”‚  User-scoped keys
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+**Related Services:**
+- fm-case-service (8003) - Case management
+- fm-knowledge-service (8002) - Knowledge base
+- fm-evidence-service (8004) - Evidence artifacts
+
+**Storage Details:**
+
+- **Database**: Redis (in-memory key-value store)
+- **Connection**: redis-py async client
+- **Key Pattern**: `session:{{user_id}}:{{session_id}}`
+- **Data Format**: JSON serialized session objects
+- **TTL**: Configurable per session (default 24 hours)
+- **Persistence**: Optional (configure Redis AOF/RDB)
+
+## Testing
+
+```bash
+# Install dev dependencies
+pip install -e ".[dev]"
+
+# Run all tests
+pytest
+
+# Run with coverage report
+pytest --cov=session_service --cov-report=html --cov-report=term
+
+# Run specific test file
+pytest tests/test_sessions.py -v
+
+# Run with debug output
+pytest -vv -s
+```
+
+**Test Coverage Goals:**
+
+- Unit tests: Core business logic (SessionManager)
+- Integration tests: Redis operations
+- API tests: Endpoint behavior and validation
+- Target coverage: >80%
+
+## Development Workflow
+
+```bash
+# Format code with black
+black src/ tests/
+
+# Lint with flake8
+flake8 src/ tests/
+
+# Type check with mypy
+mypy src/
+
+# Run all quality checks
+black src/ tests/ && flake8 src/ tests/ && mypy src/ && pytest
+```
+
+## Related Projects
+
+- [faultmaven](https://github.com/FaultMaven/faultmaven) - Main backend with API Gateway and orchestration
+- [faultmaven-copilot](https://github.com/FaultMaven/faultmaven-copilot) - Browser extension UI for troubleshooting
+- [faultmaven-deploy](https://github.com/FaultMaven/faultmaven-deploy) - Docker Compose deployment configurations
+- [fm-case-service](https://github.com/FaultMaven/fm-case-service) - Case management
+- [fm-knowledge-service](https://github.com/FaultMaven/fm-knowledge-service) - Knowledge base and recommendations
+- [fm-evidence-service](https://github.com/FaultMaven/fm-evidence-service) - Evidence artifact storage
+
+## CI/CD
+
+This repository uses **GitHub Actions** for automated documentation generation:
+
+**Trigger**: Every push to `main` or `develop` branches
+
+**Process**:
+1. Generate OpenAPI spec (JSON + YAML)
+2. Validate documentation completeness (fails if endpoints lack descriptions)
+3. Auto-generate this README from code
+4. Commit changes back to repository (if on main)
+
+See [.github/workflows/generate-docs.yml](.github/workflows/generate-docs.yml) for implementation details.
+
+**Documentation Guarantee**: This README is always in sync with the actual code. Any endpoint changes automatically trigger documentation updates.
+
+## License
+
+Apache 2.0 - See [LICENSE](LICENSE) for details.
+
+## Contributing
+
+Contributions welcome! Please:
+
+1. Fork the repository
+2. Create a feature branch (`git checkout -b feature/amazing-feature`)
+3. Make your changes
+4. Run tests and quality checks (`pytest && black . && flake8`)
+5. Commit with clear messages (`git commit -m 'feat: Add amazing feature'`)
+6. Push to your fork (`git push origin feature/amazing-feature`)
+7. Open a Pull Request
+
+**Code Style**: Black formatting, flake8 linting, mypy type checking
+**Commit Convention**: Conventional Commits (feat/fix/docs/refactor/test/chore)
+
+---
+
+**ðŸ“Š Documentation Statistics**
+- Total endpoints: {total_endpoints}
+- Last generated: {timestamp}
+- OpenAPI spec version: {version}
+- Generator: scripts/generate_readme.py
+- CI/CD: GitHub Actions
+
+*This README is automatically updated on every commit to ensure zero documentation drift.*
+"""
+
+    # Write README
+    readme_path = Path(__file__).parent.parent / "README.md"
+    with open(readme_path, 'w', encoding='utf-8') as f:
+        f.write(readme_content)
+
+    print(f"âœ… README.md generated successfully")
+    print(f"   Location: {readme_path}")
+    print(f"   Total endpoints documented: {total_endpoints}")
+    print(f"   Timestamp: {timestamp}")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/src/session_service/api/routes/sessions.py b/src/session_service/api/routes/sessions.py
index 070615c..baa7332 100644
--- a/src/session_service/api/routes/sessions.py
+++ b/src/session_service/api/routes/sessions.py
@@ -450,14 +450,64 @@ async def list_sessions(
 # Statistics & Extended Endpoints (Phase 4)
 # =============================================================================
 
-@router.get("/{session_id}/cases", summary="Get cases for this session")
+@router.get(
+    "/{session_id}/cases",
+    summary="Get cases for this session",
+    description="""
+Retrieves all cases associated with this troubleshooting session from fm-case-service.
+
+**Workflow**:
+1. Validates session exists and user has access
+2. Makes HTTP call to fm-case-service with session_id filter
+3. Returns list of associated cases
+
+**Request Example**:
+```
+GET /api/v1/sessions/session_abc123/cases
+Headers:
+  X-User-ID: user_123
+```
+
+**Response Example**:
+```json
+{
+  "session_id": "session_abc123",
+  "cases": [
+    {
+      "case_id": "case_xyz789",
+      "title": "Database timeout investigation",
+      "status": "investigating",
+      "created_at": "2025-11-15T10:30:00Z"
+    }
+  ],
+  "total": 1
+}
+```
+
+**Use Cases**:
+- Viewing all cases created during a troubleshooting session
+- Linking session investigations to persistent case tracking
+- Understanding case history for a session
+
+**Storage**: Redis (session data) + HTTP call to fm-case-service (case data)
+**Authorization**: Requires X-User-ID header; enforces user owns session
+**Rate Limits**: None (internal service-to-service call)
+    """,
+    responses={
+        200: {"description": "List of cases associated with this session"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        403: {"description": "User not authorized to access this session"},
+        404: {"description": "Session not found"},
+        500: {"description": "Failed to retrieve cases from fm-case-service"}
+    }
+)
 async def get_session_cases(
     session_id: str,
     user_id: str = Depends(get_user_id),
     session_manager: SessionManager = Depends(get_session_manager),
 ):
     """Get all cases associated with this session.
-    
+
     Makes HTTP call to fm-case-service to fetch cases.
     """
     try:
@@ -483,7 +533,55 @@ async def get_session_cases(
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to get cases")
 
 
-@router.get("/{session_id}/stats", summary="Get session statistics")
+@router.get(
+    "/{session_id}/stats",
+    summary="Get session statistics",
+    description="""
+Retrieves detailed statistics and metrics for a troubleshooting session.
+
+**Workflow**:
+1. Validates session exists and user has access
+2. Calculates session duration from created_at to last_activity_at
+3. Counts total messages in session
+4. Returns comprehensive statistics object
+
+**Request Example**:
+```
+GET /api/v1/sessions/session_abc123/stats
+Headers:
+  X-User-ID: user_123
+```
+
+**Response Example**:
+```json
+{
+  "session_id": "session_abc123",
+  "message_count": 42,
+  "duration_seconds": 3600,
+  "status": "in_progress",
+  "created_at": "2025-11-15T10:30:00Z",
+  "last_activity_at": "2025-11-15T11:30:00Z"
+}
+```
+
+**Use Cases**:
+- Monitoring session activity and engagement
+- Tracking investigation duration for billing or analytics
+- Identifying stale or abandoned sessions
+- Generating session activity reports
+
+**Storage**: Redis (session data read-only, no writes)
+**Authorization**: Requires X-User-ID header; enforces user owns session
+**Rate Limits**: None
+    """,
+    responses={
+        200: {"description": "Session statistics retrieved successfully"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        403: {"description": "User not authorized to access this session"},
+        404: {"description": "Session not found"},
+        500: {"description": "Failed to calculate session statistics"}
+    }
+)
 async def get_session_stats(
     session_id: str,
     user_id: str = Depends(get_user_id),
@@ -524,7 +622,63 @@ async def get_session_stats(
 # Message Management Endpoints (Phase 6.3)
 # =============================================================================
 
-@router.post("/{session_id}/messages", summary="Add message to session")
+@router.post(
+    "/{session_id}/messages",
+    summary="Add message to session",
+    description="""
+Appends a new message to the session's conversation history (user or assistant message).
+
+**Workflow**:
+1. Validates session exists and user has access
+2. Creates message object with role, content, and timestamp
+3. Appends message to session.messages array
+4. Updates session in Redis storage
+5. Returns message confirmation with updated message count
+
+**Request Example**:
+```
+POST /api/v1/sessions/session_abc123/messages
+Headers:
+  X-User-ID: user_123
+  Content-Type: application/json
+Body:
+{
+  "role": "user",
+  "content": "What's causing the database timeout?"
+}
+```
+
+**Response Example**:
+```json
+{
+  "session_id": "session_abc123",
+  "message": {
+    "role": "user",
+    "content": "What's causing the database timeout?",
+    "timestamp": "2025-11-15T10:35:00Z"
+  },
+  "total_messages": 43
+}
+```
+
+**Use Cases**:
+- Adding user questions to session conversation
+- Storing AI assistant responses in session
+- Building chat history for troubleshooting context
+- Tracking conversation flow during investigation
+
+**Storage**: Redis (writes to session.messages array)
+**Authorization**: Requires X-User-ID header; enforces user owns session
+**Rate Limits**: None (internal service call)
+    """,
+    responses={
+        200: {"description": "Message added successfully to session"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        403: {"description": "User not authorized to modify this session"},
+        404: {"description": "Session not found"},
+        500: {"description": "Failed to add message to session"}
+    }
+)
 async def add_session_message(
     session_id: str,
     message_data: dict,
@@ -559,7 +713,67 @@ async def add_session_message(
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to add message")
 
 
-@router.get("/{session_id}/messages", summary="Get session messages")
+@router.get(
+    "/{session_id}/messages",
+    summary="Get session messages",
+    description="""
+Retrieves the conversation message history for a troubleshooting session with pagination.
+
+**Workflow**:
+1. Validates session exists and user has access
+2. Retrieves session from Redis storage
+3. Applies limit to return most recent N messages
+4. Returns messages array with metadata (total count, returned count)
+
+**Request Example**:
+```
+GET /api/v1/sessions/session_abc123/messages?limit=50
+Headers:
+  X-User-ID: user_123
+```
+
+**Response Example**:
+```json
+{
+  "session_id": "session_abc123",
+  "messages": [
+    {
+      "role": "user",
+      "content": "What's causing the timeout?",
+      "timestamp": "2025-11-15T10:30:00Z"
+    },
+    {
+      "role": "assistant",
+      "content": "Let me investigate...",
+      "timestamp": "2025-11-15T10:30:05Z"
+    }
+  ],
+  "total": 42,
+  "returned": 2
+}
+```
+
+**Query Parameters**:
+- `limit`: Maximum messages to return (1-500, default 100). Returns most recent messages.
+
+**Use Cases**:
+- Displaying chat history in UI
+- Resuming troubleshooting session with context
+- Exporting conversation for documentation
+- Analyzing troubleshooting patterns
+
+**Storage**: Redis (session data read-only)
+**Authorization**: Requires X-User-ID header; enforces user owns session
+**Rate Limits**: None
+    """,
+    responses={
+        200: {"description": "Session messages retrieved successfully"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        403: {"description": "User not authorized to access this session"},
+        404: {"description": "Session not found"},
+        500: {"description": "Failed to retrieve session messages"}
+    }
+)
 async def get_session_messages(
     session_id: str,
     user_id: str = Depends(get_user_id),
@@ -594,7 +808,70 @@ async def get_session_messages(
 # Search & Archive Endpoints (Phase 6.3)
 # =============================================================================
 
-@router.post("/search", summary="Search sessions")
+@router.post(
+    "/search",
+    summary="Search sessions",
+    description="""
+Searches and filters the user's troubleshooting sessions based on status, title query, and other criteria.
+
+**Workflow**:
+1. Retrieves all user sessions from Redis (up to 1000 sessions)
+2. Applies status filter if provided (active, in_progress, completed, archived, abandoned)
+3. Applies text query filter on session titles (case-insensitive substring match)
+4. Limits results to requested page size
+5. Returns matching sessions with metadata
+
+**Request Example**:
+```
+POST /api/v1/sessions/search
+Headers:
+  X-User-ID: user_123
+  Content-Type: application/json
+Body:
+{
+  "status": "in_progress",
+  "query": "database",
+  "limit": 20
+}
+```
+
+**Response Example**:
+```json
+{
+  "sessions": [
+    {
+      "session_id": "session_abc123",
+      "title": "Database timeout investigation",
+      "status": "in_progress",
+      "created_at": "2025-11-15T10:30:00Z",
+      "message_count": 42
+    }
+  ],
+  "total": 1
+}
+```
+
+**Search Parameters**:
+- `status` (optional): Filter by session status
+- `query` (optional): Text search in session titles
+- `limit` (optional): Maximum results to return (default 50)
+
+**Use Cases**:
+- Finding active investigations by keyword
+- Listing sessions by status (e.g., all archived sessions)
+- Searching for sessions related to specific issues
+- Building custom session dashboards
+
+**Storage**: Redis (read-only search across user's sessions)
+**Authorization**: Requires X-User-ID header; only searches user's own sessions
+**Rate Limits**: None (searches limited to 1000 sessions max)
+    """,
+    responses={
+        200: {"description": "Search completed successfully with matching sessions"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        500: {"description": "Failed to search sessions"}
+    }
+)
 async def search_sessions(
     search_params: dict,
     user_id: str = Depends(get_user_id),
@@ -634,7 +911,57 @@ async def search_sessions(
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to search sessions")
 
 
-@router.post("/{session_id}/archive", summary="Archive session")
+@router.post(
+    "/{session_id}/archive",
+    summary="Archive session",
+    description="""
+Archives a troubleshooting session by changing its status to 'archived', marking it as inactive but preserved.
+
+**Workflow**:
+1. Validates session exists and user has access
+2. Updates session status to 'archived' in Redis
+3. Preserves all session data (messages, metadata, timestamps)
+4. Returns confirmation with new status
+
+**Request Example**:
+```
+POST /api/v1/sessions/session_abc123/archive
+Headers:
+  X-User-ID: user_123
+```
+
+**Response Example**:
+```json
+{
+  "session_id": "session_abc123",
+  "status": "archived"
+}
+```
+
+**Use Cases**:
+- Archiving completed investigations for reference
+- Cleaning up inactive sessions without deleting data
+- Organizing session workspace (hide old sessions from active list)
+- Preserving session history for compliance or audit
+
+**Behavior**:
+- Session data remains in Redis (not deleted)
+- Session can be restored later via /restore endpoint
+- Archived sessions excluded from default session lists
+- All messages and metadata preserved
+
+**Storage**: Redis (updates session.status field)
+**Authorization**: Requires X-User-ID header; enforces user owns session
+**Rate Limits**: None
+    """,
+    responses={
+        200: {"description": "Session archived successfully"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        403: {"description": "User not authorized to archive this session"},
+        404: {"description": "Session not found"},
+        500: {"description": "Failed to archive session"}
+    }
+)
 async def archive_session(
     session_id: str,
     user_id: str = Depends(get_user_id),
@@ -660,7 +987,57 @@ async def archive_session(
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to archive session")
 
 
-@router.post("/{session_id}/restore", summary="Restore archived session")
+@router.post(
+    "/{session_id}/restore",
+    summary="Restore archived session",
+    description="""
+Restores an archived troubleshooting session by changing its status back to 'active', making it available again.
+
+**Workflow**:
+1. Validates session exists and user has access
+2. Updates session status from 'archived' to 'active' in Redis
+3. Session becomes visible in default session lists again
+4. Returns confirmation with new status
+
+**Request Example**:
+```
+POST /api/v1/sessions/session_abc123/restore
+Headers:
+  X-User-ID: user_123
+```
+
+**Response Example**:
+```json
+{
+  "session_id": "session_abc123",
+  "status": "active"
+}
+```
+
+**Use Cases**:
+- Resuming investigation from archived session
+- Re-opening completed troubleshooting for follow-up
+- Unarchiving sessions mistakenly archived
+- Bringing back reference sessions for similar issues
+
+**Behavior**:
+- All session data restored to active state (messages, metadata intact)
+- Session appears in default session lists
+- Can continue adding messages and updating session
+- No data loss during archive/restore cycle
+
+**Storage**: Redis (updates session.status field)
+**Authorization**: Requires X-User-ID header; enforces user owns session
+**Rate Limits**: None
+    """,
+    responses={
+        200: {"description": "Session restored successfully"},
+        401: {"description": "X-User-ID header missing or invalid"},
+        403: {"description": "User not authorized to restore this session"},
+        404: {"description": "Session not found"},
+        500: {"description": "Failed to restore session"}
+    }
+)
 async def restore_session(
     session_id: str,
     user_id: str = Depends(get_user_id),
-- 
2.43.0

